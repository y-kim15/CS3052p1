package matrixmultiplication;

import matrixmultiplication.CRSImplementation.CRS;
import matrixmultiplication.HashMapImplementation.MapMatrix;
import matrixmultiplication.HashMapImplementation.Pair;
import matrixmultiplication.JSAImplementation.JavaSparseArray;
import matrixmultiplication.IntMatrixMultiplication.IntMatrix;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;

import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static java.lang.Math.pow;
import static java.lang.Math.round;

/**
 * Class containing all utilised methods for computation and testing
 */
public class Utils {
    // the maximum entry value of a matrix
    private static final int RANGE=9;

    /**
     * Generates a sparse matrix according to controlled variables
     * @param sparsity a float value determining the minimal sparsity of the matrix. The value represents the proportion of zero entries
     *                 the value should be at least 0.5.
     * @param positions a integer value denoting the structure of the matrix 0) random (equivalent to getSparseMatrix method)
     *                 1) a band matrix 2) an upper triangle matrix (clustered)
     * @param range maximum integer value for matrix entry
     * @param n dimension of a square matrix
     * @return MatrixData class instance including a n*n sparse matrix and the number of non zeros
     */
    public static MatrixData getSparseMatrix(double sparsity, int positions, int range, int n){
        int[][] matrix = new int[n][n];
        int total = (int)pow(n,2);

        Random r = new Random();
        int nZeros = (int)round(sparsity*total);
        boolean extraDone = false;
        if(positions == 1){
            int nnz = total-nZeros;
            int extra = nnz-n; //extra to be placed randomly;
            int num = extra/n; int rem = extra%n;
            int outer = (nnz > n)? n : nnz;
            for(int i=0; i<outer; i++) {
                int loop = num;
                if (rem > 0) {
                    loop += 1;
                    rem--;
                }
                matrix[i][i] = r.nextInt(range) + 1;
                if(extraDone) break;
                for (int j = 1; j <= loop; j++) {
                    int val = r.nextInt(range)+1;
                    if(i+j<n){
                        matrix[i][i+1] = val;
                        extra--;
                        if(extra==0){
                            extraDone = true;
                            break;
                        }
                    }
                    if(i-j>=0) {
                        matrix[i][i-1] = r.nextInt(range) + 1;
                        extra--;
                        if(extra==0){
                            extraDone=true;
                            break;
                        }
                    }

                }


            }
        }
        else if(positions == 2){
            int nnz = total-nZeros;
            int start = 0;
            for(int i=0; i<n; i++){
                for(int j=start; j<n; j++){
                    matrix[i][j] = r.nextInt(range)+1;
                    nnz--;
                    if(nnz==0) return new MatrixData(matrix,total-nZeros);
                }
                start++;
            }
        }
        else{
            // generates random sequence of indices to place values
            List<Integer> list = IntStream.rangeClosed(0, n*n-1)
                    .boxed().collect(Collectors.toList());
            Collections.shuffle(list);
            // non zero value generated by random is capped to be between 1 and RANGE
            for(int i=0; i<total-nZeros; i++){//n*n
                int val = list.get(i);
                int first=(val/n); int second=(val%n);
                matrix[first][second]=r.nextInt(range)+1;
            }

        }


        return new MatrixData(matrix, total-nZeros);
    }


    /**
     * Converts integer array to double array by iteration
     * @param array integer array
     * @return double array containing the values from array
     */
    public static double[][] convertIntToDoubleArray(int[][] array){
        int n = array.length;
        double[][] converted = new double[n][n];
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                converted[i][j] = (double)array[i][j];
            }
        }
        return converted;
    }

    /**
     * Creates JSA instance as a matrix
     * @param matrix integer 2D array containing entry values for JSA
     * @return JSA instance
     */
    public static JavaSparseArray getJSA(int[][] matrix){
        int[][] values = new int[matrix.length][];
        int[][] index = new int[matrix.length][];
        int nnz=0;
        for(int i =0; i<matrix.length; i++){
            List<Integer> rowi = new ArrayList<>();
            List<Integer> rowv = new ArrayList<>();
            for(int j=0; j<matrix.length; j++){
                if(matrix[i][j]>0){
                    nnz++;
                    rowv.add(matrix[i][j]);
                    rowi.add(j);
                }
            }
            int[] rowi1 = rowi.stream().mapToInt(Integer:: intValue).toArray();
            int[] rowv1 = rowv.stream().mapToInt(Integer:: intValue).toArray();
            index[i] = rowi1;
            values[i] = rowv1;

        }
        return new JavaSparseArray(values, index,nnz);
    }

    /**
     * Converts a JSA instance to an IntMatrix matrix
     * @param a a JSA instance
     * @return a converted IntMatrix matrix
     */
    public static IntMatrix convertToIntMatrix(JavaSparseArray a){
        int n = a.getDim();
        IntMatrix b = new IntMatrix(n);
        int[][] v = a.getValueA();
        int[][] i = a.getIndexA();
        for(int j=0; j<n; j++){
            int[] ind = i[j];
            int[] val = v[j];
            int k=0, pos =k;
            for(k=0; k<n; k++){
                if(ind.length>0 && k==ind[pos]){
                    b.set(j,k,val[pos]);
                    pos++;
                    if(pos==ind.length) pos--;
                }

            }
        }
        return b;
    }

    /**
     * Creates an CRS instance of a matrix
     * @param values integer 2d array containing entries of a matrix
     * @param nnz the number of non zero values in the matrix
     * @return a CRS instance containing non zero values
     */
    public static CRS getCRS(int[][] values, int nnz){
        int n = values.length;
        CRS c = new CRS(n,nnz);
        c.setRowPtr(0,0);
        int curNnz=0;
        for(int i=0; i<n; i++){
            int[] row = values[i];
            int rowP=0;
            for(int j=0; j<n; j++){
                if(row[j]>0){
                    c.setValue(curNnz,row[j]);
                    c.setColInd(curNnz,j);
                    curNnz++;
                    rowP++;
                }
            }
            c.setRowPtr(i+1,c.getRowPtr(i)+rowP);
        }
        return c;
    }

    /**
     * Creates an MapMatrix instance of a matrix
     * @param values integer 2d array containing entries of a matrix
     * @param nnz the number of non zero values in the matrix
     * @return a MapMatrix instance containing the matrix
     */
    public static MapMatrix getMapMatrix(int[][] values, int nnz){
        MapMatrix mat = new MapMatrix(nnz, values.length);
        for(int i=0; i<values.length; i++){
            for(int j=0; j<values.length; j++){
                if(values[i][j]>0){
                    mat.put(i,j,values[i][j]);
                }
            }
        }
        return mat;
    }

    /**
     * Converts a MapMatrix instance to an IntMatrix matrix
     * @param map instance to convert
     * @return converted
     */
    public static IntMatrix convertToIntMatrix(MapMatrix map){
        IntMatrix matrix = new IntMatrix(map.getDim());
        HashMap<Pair,Integer> map1 = map.getMatrix();
        int nnz = map.getNnz();
        int n = map.getDim();
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(nnz==0) return matrix;
                if(map.getMatrix().containsKey(new Pair(i,j))){
                    int val = map1.get(new Pair(i,j));
                    matrix.set(i,j,val);
                    nnz--;
                }

            }
        }
        return matrix;
    }


    /**
     * Creates a list of lists of objects (Matrices) to be used for testing.
     * Generates matrices according to the parameter values
     * @param min minimum dimension of a matrix
     * @param max maximum dimension of a matrix
     * @param nEach the number of matrices to be generated for each chosen length
     * @param step the step size to increase from minimum to maximum dimension for each iteration
     * @param sparsity double value to define sparsity of a matrix
     * @param matrixType type of an matrix to generate
     * @return an iterable list containing matrices data for testing
     */
    public static List<Object[]> getParamsByConditions(int min, int max, int nEach, int step, double sparsity, int matrixType){
        List<Object[]> list = new ArrayList<>();
        for(int i=min; i<=max; i+=step){
            // how many matrices of equal length we will have
            for(int o=0; o<nEach; o++){
                Object[] ob=new Object[3];
                // generates two matrix for each parameterised test
                for(int j=0;j<2;j++){
                    MatrixData p = Utils.getSparseMatrix(sparsity, matrixType,RANGE, i);
                    ob[j] = p;
                }
                ob[2]=i;
                list.add(ob);
            }
        }
        return list;
    }

    /**
     * writes input line to a file
     * attributed to : https://www.mkyong.com/java/how-to-export-data-to-csv-file-java/
     * @param writer file to write
     * @param inputs strings to write
     * @throws IOException when file is not defined
     */
    public static void writeCSVLine(FileWriter writer, List<String> inputs)throws IOException{
        StringBuilder sb = new StringBuilder();
        sb.append(inputs.get(0));
        for(int i=1; i<inputs.size(); i++){
            sb.append(",");
            sb.append(inputs.get(i));
        }
        sb.append("\n");
        try{
            writer.append(sb.toString());
        }
        catch (IOException e){
            e.getMessage();
            System.out.println("Failed to write input line to CSV");
        }

    }

    /**
     * Constructs a meaningful file name for test output
     * @param testName name of the test
     * @param sparsity sparsity of matrices used for testing
     * @param matrixType type of matrices used for testing
     * @return file name built
     */
    public static String getFileName(String testName, double sparsity, int matrixType, boolean inOrOut){
        StringBuilder sb = new StringBuilder();
        if(inOrOut){
            switch (testName){
                case "comp":
                case "basic": sb.append("./data/Input/");
                            break;
                case "new_comp":
                case "new_basic": sb.append("./output/Input/");
                                break;
            }
        }
        else {
            sb.append("./output/Result");
        }
        sb.append(testName);
        sb.append("_");
        sb.append(sparsity);
        sb.append("_");
        switch (matrixType){
            case 0: sb.append("random");
                    break;
            case 1: sb.append("band");
                    break;
            case 2: sb.append("triangle");
                    break;
        }
        if(inOrOut) sb.append("_input.csv");
        else sb.append("_output.csv");
        return sb.toString();
    }


    /**
     * Reads CSV file containing matrix inputs, initially written using Data.java
     * Format the input to be passed to parameterised tests
     * @param filepath path to the file to read
     * @param min the minimum dimension
     * @param max the maximum dimension
     * @param repeat the number of repetition
     * @param step the step size to increase dimension
     * @return a list of arrays of MatrixData
     * @throws IOException when file path is invalid
     */
    public static List<Object[]> getParams(String filepath, int min, int max, int repeat, int step)throws IOException{

        List<Object[]> list = new ArrayList<>();
        try {
            BufferedReader r = new BufferedReader(new FileReader(filepath));
            String line = "";

            for(int i=min; i<=max; i+=step){
                // how many matrices of equal length we will have
                for(int o=0; o<repeat; o++){
                    Object[] ob=new Object[3];
                    // generates two matrix for each parameterised test
                    for(int j=0;j<2;j++){
                        int[][] values = new int[i][i];
                        line = r.readLine();
                        String[] vals = line.split(",");
                        int nnz = 0;
                        for(int s=0; s < i; s++){
                            int upto = i;
                            if(s == i-1){
                                String[] split = vals[s].split(";");
                                upto = split[0].length();
                                nnz = Integer.parseInt(split[1]);//Character.toString(vals[s].charAt(i-1)));
                            }
                            for(int k=0;k < upto; k++){
                                values[s][k] =Integer.parseInt(Character.toString(vals[s].charAt(k)));
                            }
                        }
                        MatrixData mat = new MatrixData(values, nnz);
                        ob[j] = mat;
                    }
                    ob[2]=i;
                    list.add(ob);
                }
            }
        }
        catch (IOException e){
            System.out.println("file path issue");
        }

        return list;
    }

    /**
     * Stores values of a matrix in a string format to be saved in a CSV file
     * @param data a pair data containing 2D int array and int for nnz value
     * @return a string containing values separated by commas for row.
     * Important thing to note is that we set all entries to be one digit number.
     */
    public static String makeString(MatrixData data){
        StringBuilder builder = new StringBuilder();
        int[][] v = data.values;
        for(int i =0; i < v.length; i++){
            for(int j=0; j < v.length; j++){
                builder.append(Integer.toString(v[i][j])+"");
            }
            if(i < v.length-1)builder.append(",");

        }
        builder.append(";");
        builder.append(data.nnz);
        builder.append("\n");
        return builder.toString();
    }

    /**
     * Writes input matrices to a CSV file
     * https://stackoverflow.com/questions/34958829/how-to-save-a-2d-array-into-a-text-file-with-bufferedwriter
     * @param filePath file to write
     * @param data a list of arrays containing matrices to write
     * @throws IOException occurs when the file path is invalid
     */
    public static void writeOutData(String filePath, List<Object[]> data) throws IOException{
        try{
            Files.deleteIfExists(Paths.get(filePath));
            BufferedWriter w = new BufferedWriter(new FileWriter(filePath));
            for(int i=0; i< data.size(); i++){
                for(int j=0; j< 2; j++){
                    MatrixData d = (MatrixData) data.get(i)[j];
                    String matStr = makeString(d);
                    w.write(matStr);

                }
            }
            w.close();
        }
        catch (IOException e){
            System.out.println(e.getMessage());
        }
    }
}
