package matrixmultiplication;

import matrixmultiplication.CRSImplementation.CRS;
import matrixmultiplication.HashMapImplementation.MapMatrix;
import matrixmultiplication.HashMapImplementation.Pair;
import matrixmultiplication.JSAImplementation.JavaSparseArray;
import matrixmultiplication.IntMatrixMultiplication.IntMatrix;

import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

import java.util.stream.Collectors;
import java.util.stream.IntStream;

import static java.lang.Math.pow;
import static java.lang.Math.round;

/**
 * Class containing all utilised methods for computation and testing
 */
public class Utils {
    // the maximum entry value of a matrix
    private static final int RANGE=10;

    /**
     * Generates a sparse matrix according to controlled variables
     * @param sparsity a float value determining the minimal sparsity of the matrix. The value represents the proportion of zero entries
     *                 the value should be at least 0.5.
     * @param positions a integer value denoting the structure of the matrix 0) random (equivalent to getSparseMatrix method)
     *                 1) a band matrix 2) an upper triangle matrix (clustered)
     * @param range maximum integer value for matrix entry
     * @param n dimension of a square matrix
     * @return MatrixData class instance including a n*n sparse matrix and the number of non zeros
     */
    public static MatrixData getSparseMatrix(double sparsity, int positions, int range, int n){
        int[][] matrix = new int[n][n];
        int total = (int)pow(n,2);

        Random r = new Random();
        int nZeros = (int)round(sparsity*total);
        boolean extraDone = false;
        if(positions == 1){
            int nnz = total-nZeros;
            int extra = nnz-n; //extra to be placed randomly;
            int num = extra/n; int rem = extra%n;
            int outer = (nnz > n)? n : nnz;
            for(int i=0; i<outer; i++) {
                int loop = num;
                if (rem > 0) {
                    loop += 1;
                    rem--;
                }
                matrix[i][i] = r.nextInt(range) + 1;
                if(extraDone) break;
                for (int j = 1; j <= loop; j++) {
                    int val = r.nextInt(range)+1;
                    if(i+j<n){
                        matrix[i][i+1] = val;
                        extra--;
                        if(extra==0){
                            extraDone = true;
                            break;
                        }
                    }
                    if(i-j>=0) {
                        matrix[i][i-1] = r.nextInt(range) + 1;
                        extra--;
                        if(extra==0){
                            extraDone=true;
                            break;
                        }
                    }

                }


            }
        }
        else if(positions == 2){
            int nnz = total-nZeros;
            int start = 0;
            for(int i=0; i<n; i++){
                for(int j=start; j<n; j++){
                    matrix[i][j] = r.nextInt(range)+1;
                    nnz--;
                    if(nnz==0) return new MatrixData(matrix,total-nZeros);
                }
                start++;
            }
        }
        else{
            // generates random sequence of indices to place values
            List<Integer> list = IntStream.rangeClosed(0, n*n-1)
                    .boxed().collect(Collectors.toList());
            Collections.shuffle(list);
            // non zero value generated by random is capped to be between 1 and RANGE
            for(int i=0; i<total-nZeros; i++){//n*n
                int val = list.get(i);
                int first=(val/n); int second=(val%n);
                matrix[first][second]=r.nextInt(RANGE)+1;
            }

        }


        return new MatrixData(matrix, total-nZeros);
    }


    /**
     * Converts integer array to double array by iteration
     * @param array integer array
     * @return double array containing the values from array
     */
    public static double[][] convertIntToDoubleArray(int[][] array){
        int n = array.length;
        double[][] converted = new double[n][n];
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                converted[i][j] = (double)array[i][j];
            }
        }
        return converted;
    }

    /**
     * Creates JSA instance as a matrix
     * @param matrix integer 2D array containing entry values for JSA
     * @return JSA instance
     */
    public static JavaSparseArray getJSA(int[][] matrix){
        int[][] values = new int[matrix.length][];
        int[][] index = new int[matrix.length][];
        int nnz=0;
        for(int i =0; i<matrix.length; i++){
            List<Integer> rowi = new ArrayList<>();
            List<Integer> rowv = new ArrayList<>();
            for(int j=0; j<matrix.length; j++){
                if(matrix[i][j]>0){
                    nnz++;
                    rowv.add(matrix[i][j]);
                    rowi.add(j);
                }
            }
            int[] rowi1 = rowi.stream().mapToInt(Integer:: intValue).toArray();
            int[] rowv1 = rowv.stream().mapToInt(Integer:: intValue).toArray();
            index[i] = rowi1;
            values[i] = rowv1;

        }
        return new JavaSparseArray(values, index,nnz);
    }

    /**
     * Converts a JSA instance to an IntMatrix matrix
     * @param a a JSA instance
     * @return a converted IntMatrix matrix
     */
    public static IntMatrix convertToIntMatrix(JavaSparseArray a){
        int n = a.getDim();
        IntMatrix b = new IntMatrix(n);
        int[][] v = a.getValueA();
        int[][] i = a.getIndexA();
        for(int j=0; j<n; j++){
            int[] ind = i[j];
            int[] val = v[j];
            int k=0, pos =k;
            for(k=0; k<n; k++){
                if(ind.length>0 && k==ind[pos]){
                    b.set(j,k,val[pos]);
                    pos++;
                    if(pos==ind.length) pos--;
                }

            }
        }
        return b;
    }

    /**
     * Creates an CRS instance of a matrix
     * @param values integer 2d array containing entries of a matrix
     * @param nnz the number of non zero values in the matrix
     * @return a CRS instance containing non zero values
     */
    public static CRS getCRS(int[][] values, int nnz){
        int n = values.length;
        CRS c = new CRS(n,nnz);
        c.setRowPtr(0,0);
        int curNnz=0;
        for(int i=0; i<n; i++){
            int[] row = values[i];
            int rowP=0;
            for(int j=0; j<n; j++){
                if(row[j]>0){
                    c.setValue(curNnz,row[j]);
                    c.setColInd(curNnz,j);
                    curNnz++;
                    rowP++;
                }
            }
            c.setRowPtr(i+1,c.getRowPtr(i)+rowP);
        }
        return c;
    }

    /**
     * Creates an MapMatrix instance of a matrix
     * @param values integer 2d array containing entries of a matrix
     * @param nnz the number of non zero values in the matrix
     * @return a MapMatrix instance containing the matrix
     */
    public static MapMatrix getMapMatrix(int[][] values, int nnz){
        MapMatrix mat = new MapMatrix(nnz, values.length);
        for(int i=0; i<values.length; i++){
            for(int j=0; j<values.length; j++){
                if(values[i][j]>0){
                    mat.put(i,j,values[i][j]);
                }
            }
        }
        return mat;
    }

    /**
     * Converts a MapMatrix instance to an IntMatrix matrix
     * @param map instance to convert
     * @return converted
     */
    public static IntMatrix convertToIntMatrix(MapMatrix map){
        IntMatrix matrix = new IntMatrix(map.getDim());
        HashMap<Pair,Integer> map1 = map.getMatrix();
        int nnz = map.getNnz();
        int n = map.getDim();
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                if(nnz==0) return matrix;
                if(map.getMatrix().containsKey(new Pair(i,j))){
                    int val = map1.get(new Pair(i,j));
                    matrix.set(i,j,val);
                    nnz--;
                }

            }
        }
        return matrix;
    }


    /**
     * Creates a list of lists of objects (Matrices) to be used for testing.
     * Generates matrices according to the parameter values
     * @param min minimum dimension of a matrix
     * @param max maximum dimension of a matrix
     * @param nEach the number of matrices to be generated for each chosen length
     * @param step the step size to increase from minimum to maximum dimension for each iteration
     * @param sparsity double value to define sparsity of a matrix
     * @param matrixType type of an matrix to generate
     * @return an iterable list containing matrices data for testing
     */
    public static List<Object[]> getParamsByConditions(int min, int max, int nEach, int step, double sparsity, int matrixType){
        List<Object[]> list = new ArrayList<>();
        for(int i=min; i<=max; i+=step){
            // how many matrices of equal length we will have
            for(int o=0; o<nEach; o++){
                Object[] ob=new Object[3];
                // generates two matrix for each parameterised test
                for(int j=0;j<2;j++){
                    MatrixData p = Utils.getSparseMatrix(sparsity, matrixType,RANGE, i);
                    ob[j] = p;
                }
                ob[2]=i;
                list.add(ob);
            }
        }
        return list;
    }

    /**
     * writes input line to a file
     * attributed to : https://www.mkyong.com/java/how-to-export-data-to-csv-file-java/
     * @param writer file to write
     * @param inputs strings to write
     * @throws IOException when file is not defined
     */
    public static void writeCSVLine(FileWriter writer, List<String> inputs)throws IOException{
        StringBuilder sb = new StringBuilder();
        sb.append(inputs.get(0));
        for(int i=1; i<inputs.size(); i++){
            sb.append(",");
            sb.append(inputs.get(i));
        }
        sb.append("\n");
        try{
            writer.append(sb.toString());
        }
        catch (IOException e){
            e.getMessage();
            System.out.println("Failed to write input line to CSV");
        }

    }

    /**
     * Constructs a meaningful file name for test output
     * @param testName name of the test
     * @param sparsity sparsity of matrices used for testing
     * @param matrixType type of matrices used for testing
     * @return file name built
     */
    public static String getFileName(String testName, double sparsity, int matrixType){
        StringBuilder sb = new StringBuilder();
        sb.append("./output/");
        sb.append(testName);
        sb.append("_");
        sb.append(sparsity);
        sb.append("_");
        switch (matrixType){
            case 0: sb.append("random");
                    break;
            case 1: sb.append("band");
                    break;
            case 2: sb.append("triangle");
                    break;
        }
        sb.append("_mul_output.csv");
        return sb.toString();
    }
}
